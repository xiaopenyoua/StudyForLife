# 对象 -- Object

1. `toString` 方式

```
Object.prototype.toString.call(val) === '[object Object]' // true 代表为对象
```

> 所有数据类型的父类都是 `object`,`toString` 为 `Object` 的原生方法,默认返回的是 `[ Object.xxx ]`,但是有些复杂数据类型已经重写 toString,所以需要使用 `call()` 或 `apply()` 来调用原始的 `toString`

[在 toString 方法被调用时,会执行下面的操作步骤](https://blog.csdn.net/u014481405/article/details/107914835):

- 获取 this 对象的 `[[Class]]` 属性的值.（第一步）

- 计算出三个字符串 `"[object ", 第一步的操作结果Result(1), 以及 "]"` 连接后的新字符串.（第二步）

- 返回第二步的操作结果 Result(2). （第三步）

> 默认情况下，toString() 不接受任何参数。然而，继承自 Object 的对象可能用它们自己的 `实现重写` 它，这些实现可以接受参数。例如，Number.prototype.toString() 和 BigInt.prototype.toString() 方法接受一个可选的 radix 参数。

```
Object.toString.call(Array)//"function Array() { [native code] }"
Object.prototype.toString.call(Array)//"[object Function]"

Object.toString()//"function Object() { [native code] }"
Object.prototype.toString()//"[object Object]"

```

> 1. 首先需要了解 `Object.prototype.toString()` 的原理和各值返回的字符串。
> 2. `Object.prototype.toString()` 与 `Object.toString()` 是两个不同的方法，他们返回的值是不一样的。前者返回的是该对象类型的字符串，后者返回的是一个函数代码
> 3. 为什么数组、布尔等不直接调用 `toString()`,因为它们自己的原型对象上重写了 `toString()` 代表各自不同的逻辑。需要调用 `Ojbect` 原型对象上的 `toString()` 去判断类型

---

2. `constructor` 方式

```
var arr = ['aa','bb','cc'];
var obj = {
'a': 'aa',
'b': 'bb',
'c': 'cc'
};
console.log(arr.constructor === Array); //true
console.log(arr.constructor === Object); //false
console.log(obj.constructor === Object); //true
```

> 原型对象：拥有 `prototype` 属性的对象，在定义函数时就被创建
> 此属性只有原型对象才有，它默认指回 `prototype` 属性所在的构造函数。
> 除了 `null` && `undefined` 之外其他类型数据均可使用 `constructor`

---

3. `typeof`

```
typeof val === 'object' && v !== null   // true 代表为对象
```

| 类型                     | 结果      |
| ------------------------ | --------- |
| Undefined                | undefined |
| Null                     | `object`  |
| Boolean                  | boolean   |
| Number                   | number    |
| Bigint                   | bigint    |
| String                   | string    |
| Symbol                   | symbol    |
| Function                 | function  |
| 其他任何对象(包括 Array) | `object`  |

> 除了 null，所有原始类型都可以使用 typeof 运算符测试。typeof null 返回 "object"，因此必须使用 === null 来测试 null。

---

4. `instanceof` 方式

```
var arr = new Array();

var arr = ['aa','bb','cc'];

var obj = { a: 'aa', b: 'bb', c: 'cc' };

console.log(arr instanceof Array); //true

console.log(arr instanceof Object); //true

console.log(obj instanceof Array); //false

console.log(obj instanceof Object); //true
```

> 使用 `instanceof` 可以用来判断一个变量是数组还是对象，原理如下：
> 数组也是对象的一种，因此用 `arr instanceof Object` 也为 `true`。
> `instanceof` 用于检测某个属性是否出现在某个实例的原型链上
> `instanceof` 只适用于引用类型

- `instanceof` 原理

![](https://images2018.cnblogs.com/blog/1265396/201711/1265396-20171127092153300-1935600767.png)

instanceof 是判断实例对象的`__proto__`和生成该实例的构造函数的 prototype 是不是引用的同一个地址。

是返回 true，否返回 false。

---

# 原始类型

1. `typeof`

| 类型      | typeof 返回值 | 对象包装器 |
| --------- | ------------- | ---------- |
| Null      | "object"      | N/A        |
| Undefined | "undefined"   | N/A        |
| Boolean   | "boolean"     | Boolean    |
| Number    | "number"      | Number     |
| BigInt    | "bigint"      | BigInt     |
| String    | "string"      | String     |
| Symbol    | "symbol"      | Symbol     |

---

2. [`instanceof` 方式](https://blog.csdn.net/qq_40868156/article/details/124688170)

```
let str = 'string'
str instanceof String // false
```

```
let str =new String('string')
str instanceof String // true
```

3. `Object.prototype.toString.call(val)`

# 数组

> 同对象的那几种方法（typeof 除外）

1. `Array.isArray()`

```
let a = [1,2,3]
Array.isArray(a);//true
```

> Array.isArray() 是在 ES5 中提出，也就是说在 ES5 之前可能会存在不支持此方法的情况
