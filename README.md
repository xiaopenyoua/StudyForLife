# HTML + CSS

1. * [讲一下盒模型，普通盒模型和怪异盒模型有什么区别？](https://juejin.cn/post/7220775341605339194)

2. [块元素和行内元素区别是什么？常见块元素和行内元素有哪些？](https://blog.csdn.net/m0_51273200/article/details/120336046)

3. * [HTML 语义化标签 有哪些？](https://juejin.cn/post/6844903544995184653)

4. [伪类和伪元素的区别是什么？](https://github.com/pro-collection/interview-question/issues/354)

5. * [CSS 如何实现垂直居中？](https://github.com/pro-collection/interview-question/issues/36)

6. [CSS 常见的选择器有哪些？](https://github.com/pro-collection/interview-question/issues/353)

7. CSS 的优先级如何计算？

8. [长度单位 px、em 和 rem 的区别是什么？](https://github.com/febobo/web-interview/blob/master/docs/css/em_px_rem_vh_vw.md)

9. [讲一下 flex 弹性盒布局？](https://github.com/pro-collection/interview-question/issues/100)

10. [浮动塌陷问题解决方法是什么？](https://juejin.cn/post/7074581427571916807)

11. [position 属性的值有哪些？各个值是什么含义？](https://github.com/pro-collection/interview-question/issues/158)

12. [BFC、IFC 是什么？](https://juejin.cn/post/7072174649735381029)

13. [多列等高布局](https://juejin.cn/post/7197614864364273722)

14. [CSS Grid 布局](https://github.com/pro-collection/interview-question/issues/420)

15. [清除浮动的解决方案](https://github.com/pro-collection/interview-question/issues/55)

16. [如何避免全局样式污染？](https://github.com/pro-collection/interview-question/issues/422)

17. [CSS Module 是什么？](https://github.com/pro-collection/interview-question/issues/589)

---

# JavaScript

1. [谈谈对原型链的理解。](https://github.com/pro-collection/interview-question/issues/32)

2. [js 如何实现继承？](https://github.com/pro-collection/interview-question/issues/31)

3. js 有哪些数据类型？

4. js 有哪些判断类型的方法？

5. [如何判断一个变量是否数组？](https://github.com/pro-collection/interview-question/issues/431)

6. [Null 和 undefined 的区别？](https://github.com/pro-collection/interview-question/issues/111)

7. [call bind apply 的区别？](https://github.com/pro-collection/interview-question/issues/9) / [手写实现 call、apply、bind](https://github.com/pro-collection/interview-question/issues/84)

8. 防抖节流的概念？实现防抖和节流。[节流](https://github.com/pro-collection/interview-question/issues/53) / [防抖](https://github.com/pro-collection/interview-question/issues/51)

9. [深拷贝、浅拷贝的区别？如何实现深拷贝和浅拷贝？](https://github.com/febobo/web-interview/blob/master/docs/JavaScript/copy.md)

10. [对比 一下 var、const、let。](https://blog.csdn.net/xiewenhui111/article/details/113133330)

11. ES next 新特性有哪些？

12. [箭头函数和普通函数区别是什么？](https://github.com/pro-collection/interview-question/issues/103)

13. 使用 new 创建对象的过程是什么样的？

14. [this 指向系列问题。](https://github.com/pro-collection/interview-question/issues/519) / [哪些原因会导致js里this指向混乱?](https://github.com/pro-collection/interview-question/issues/388) -- [111](https://juejin.cn/post/6944707409596121102) --- [222](https://juejin.cn/post/7041055543984652319)

15. [谈谈对闭包的理解？什么是闭包？闭包有哪些应用场景？闭包有什么缺点？如何避免闭包？](https://github.com/pro-collection/interview-question/issues/37)

16. [谈谈对 js 事件循环的理解？](https://github.com/pro-collection/interview-question/issues/142)

17. [谈谈对 promise 理解？](https://github.com/febobo/web-interview/blob/master/docs/es6/promise.md)

18. [手写 Promise。](https://github.com/pro-collection/interview-question/issues/57)

19. [实现 Promise.all 方法。](https://github.com/pro-collection/interview-question/issues/107)

20. [Typescript 中 type 和 interface 的区别是什么？](https://github.com/pro-collection/interview-question/issues/273)

21. [讲讲 Typescript 中的泛型？](https://github.com/febobo/web-interview/blob/master/docs/typescript/generic.md)

22. [Typescript 如何实现一个函数的重载？](https://juejin.cn/post/7201883287938007096)

23. [CmmonJS 和 ESM 区别？](https://segmentfault.com/a/1190000043720379)

24. [柯里化是什么？有什么用？怎么实现？](https://github.com/pro-collection/interview-question/issues/361)

25. [讲讲 js 垃圾回收机制。](https://github.com/pro-collection/interview-question/issues/118)

26. 实现一个发布订阅。

27. [如何实现数组扁平化？](https://juejin.cn/post/7024337692108259365)

28. 如何实现数组去重？

29. [如何将JavaScript代码解析成抽象语法树(AST)](https://github.com/pro-collection/interview-question/issues/357)

[axios 是如何区分是 nodejs 环境还是 浏览器环境 的](https://github.com/pro-collection/interview-question/issues/574)

---

# Vue

[Redux 和 Vuex 的设计思想是什么](https://github.com/pro-collection/interview-question/issues/201)

[v-for 和 v-if 同时使用有问题吗？](https://github.com/pro-collection/interview-question/issues/579)

[组件通信](https://github.com/pro-collection/interview-question/issues/514)

[Vue 组件间通信方式有哪些？](https://github.com/febobo/web-interview/blob/master/docs/vue/communication.md)

---

[响应式为何要从 Object.defineProperty 改为 proxy](https://github.com/pro-collection/interview-question/issues/595) ---- [补充](https://juejin.cn/post/6998165868332990471)

> 发布订阅模式： 订阅者向事件调度中心（PubSub）注册（subscribe）监听，当事件调度中心（PubSub）发布通知时（publish），订阅者的监听事件将会被触发。
>观察者模式： 定义了对象之间 一对多 的依赖关系，它只有两个角色，分别是观察的目标对象 Subject 和观察者对象 Observer，当一个 目标对象 的状态发生改变时，所有依赖于它的 观察者对象 都会收到通知。

**整体简单的说就是，使用发布订阅模式中的特殊的一种 ---- `观察者模式`，被观察者也就是目标（数据对象），观察者（Watcher）其实就是包含组件重新渲染的 `渲染 Watcher`，用来更新View。**

**首先通过 `Object.defineProperty()` 来劫持各个属性的 `setter`，`getter`，为每一个对象属性都添加的 `get` 与 `set` 方法, 并且在每个属性的 `get()` 中 `new` 了一个 `dep` 收集当前的 `渲染 Watcher`（因为这个属性值可能会被多个View绑定）,在 `set` 方法里通知每个观察者 `渲染 Watcher` 执行 `update` 方法【`Vue 在 new 渲染 Watcher的时候会将组件挂载更新的方法(updateComponent)传入，存储在渲染watcher中。触发渲染watcher的update方法时实际上是触发这个组件挂载更新方法, 也就是在属性被修改时触发了set方法，而这个set方法会将依赖当前属性的页面重新渲染，从而达到数据驱动的效果。`】**


实现mvvm的双向绑定，是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。就必须要实现以下几点：(通过 getter 来收集视图中的依赖，在 setter 的时候更新视图)
1. 实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
  - **在get中new了一个 dep 收集当前的渲染 Watcher**
  - **在set方法中遍历收集的渲染Watcher 执行 update 方法**
2. 实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
3. 实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图
  ***Vue 在 new 渲染 Watcher的时候会将组件挂载更新的方法(updateComponent)传入，存储在渲染watcher中。触发渲染watcher的update方法时实际上是触发这个组件挂载更新方法, 也就是在属性被修改时触发了set方法，而这个set方法会将依赖当前属性的页面重新渲染，从而达到数据驱动的效果。***

---

[Vue.nextTick 的实现？](https://github.com/pro-collection/interview-question/issues/124)

[computed 和 watch 区别是什么？](https://github.com/pro-collection/interview-question/issues/277)

[动态给 data 添加一个新的属性时会发生什么](https://github.com/pro-collection/interview-question/issues/571)

[说说 Vue 的 keep-alive 使用及原理。](https://github.com/pro-collection/interview-question/issues/119)

[使用 虚拟DOM 一定会比直接操作 真实 DOM 快吗?](https://github.com/pro-collection/interview-question/issues/207)

讲讲[前端路由原理](https://github.com/pro-collection/interview-question/issues/269)。比较一下 history 和 hash 这两种路由。

[讲讲 Vue 的虚拟 DOM，原理，好处是什么？](https://github.com/febobo/web-interview/issues/23)


## Vue2

[讲讲 Vue2 双向绑定原理。](https://blog.csdn.net/qq_43574741/article/details/119326529)

[生命周期](https://blog.51cto.com/u_16171599/6561182)


## Vue3

[生命周期](https://juejin.cn/post/7233661232556343357)

[讲讲 Vue3 双向绑定原理。](https://blog.csdn.net/qq_43574741/article/details/119326529)

[vue3 性能提升主要是体现在哪些方面](https://github.com/pro-collection/interview-question/issues/395)


mvvm 和 mvc 区别是什么？

---
## 2 & 3

[vu2 和 vue3 有什么区别？](https://github.com/febobo/web-interview/blob/master/docs/vue/vue3_vue2.md) ---------   [补充](https://github.com/pro-collection/interview-question/issues/488)

[vu2 vu3 diff](https://juejin.cn/post/7092068900589797413)

面试的时候，区别如果只说文本类型打了标记，估计不会得到认可。建议配合另外一篇文章一块看。
vue2、vue3 的 diff 算法实现差异主要体现在：处理完首尾节点后，对剩余节点的处理方式。

在 vue2 中是通过对旧节点列表建立一个 { key, oldVnode }的映射表，然后遍历新节点列表的剩余节点，根据newVnode.key在旧映射表中寻找可复用的节点，然后打补丁并且移动到正确的位置。 (*用新的开始节点的key,去映射表中查找，如果找到就把该节点移动到最前面，且原来的位置用undefined占位，避免数组塌陷 防止老节点移动走了之后破坏了初始的映射表位置，如果没有找到就直接把新节点插入*)

而在 vue3 中是建立一个存储新节点数组中的剩余节点在旧节点数组上的索引的映射关系数组，建立完成这个数组后也即找到了可复用的节点，然后通过这个数组计算得到最长递增子序列，这个序列中的节点保持不动，然后将新节点数组中的剩余节点移动到正确的位置。

[Vue 父子组件生命周期触发顺序是怎样的？](https://blog.csdn.net/qq_57334853/article/details/125717202) ----- [补充](https://juejin.cn/post/7108206884867276831#heading-2)

---

# React

[讲讲 React diff 算法。](https://github.com/pro-collection/interview-question/issues/326)

[React 组件复用方式有哪几种？](https://juejin.cn/post/7034130776115396639)

[React fiber 是什么？有什么用？](https://juejin.cn/post/7243450433812070455?searchId=20231018150338D8A6D23C3F3FA5A206AE#heading-1)

[灵魂拷问——有react fiber，为什么不需要vue fiber呢](https://juejin.cn/post/7077545184807878692?searchId=20231018150338D8A6D23C3F3FA5A206AE)

React [生命周期](https://github.com/pro-collection/interview-question/issues/301)有哪些？React16 废弃了哪些？为什么要废弃？新增的生命周期钩子有哪些？有什么作用？

[如何对 React 性能优化？](https://github.com/pro-collection/interview-question/issues/584)

[开发过程中有哪些性能优化手段](https://github.com/pro-collection/interview-question/issues/305)

[React 的 setState 是同步的还是异步的？](https://github.com/pro-collection/interview-question/issues/132)

[讲讲 React 事件绑定原理。](https://github.com/pro-collection/interview-question/issues/336)

讲讲 React 的 hooks，有什么好处？[有哪些常用的 hook？](https://github.com/pro-collection/interview-question/issues/302)

[讲讲 React key 的作用。](https://github.com/pro-collection/interview-question/issues/130)

[谈谈 React 的类组件和函数式组件的区别。](https://github.com/pro-collection/interview-question/issues/476) -----  [补充](https://github.com/pro-collection/interview-question/issues/582)

[如何实现vue 中 keep-alive 的功能](https://github.com/pro-collection/interview-question/issues/580)

[react-router 页面跳转时，是如何传递下一个页面参数的](https://github.com/pro-collection/interview-question/issues/392)

[18 的新特性有哪些](https://github.com/pro-collection/interview-question/issues/299)

---

# [工程化](https://github.com/febobo/web-interview/tree/master/docs/webpack)

[对webpack的理解？解决了什么问题](https://github.com/febobo/web-interview/issues/121)

[webpack热更新](https://github.com/febobo/web-interview/blob/master/docs/webpack/HMR.md)

- 通过`webpack-dev-server`创建两个服务器：提供静态资源的服务（express）和Socket服务
- `express server` 负责直接提供静态资源的服务（打包后的资源直接被浏览器请求和解析）
- `socket server` 是一个 websocket 的长连接，双方可以通信
- 当 `socket server` 监听到对应的模块发生变化时，会生成两个文件.json（manifest文件）和.js文件（update chunk）【`manifest`（包含了 hash 和 chundId ，用来说明变化的内容）和 `chunk.js` 模块】
- 通过长连接，socket server 可以直接将这两个文件主动发送给客户端（浏览器）
- 浏览器拿到两个新的文件后，通过`HMR runtime`机制，加载这两个文件，并且针对修改的模块进行更新

[webpack 性能优化有哪些方法？](https://github.com/febobo/web-interview/issues/132) --------- [补充](https://cchroot.github.io/interview/pages/interview%20notes/Webpack%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html#%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F%E6%80%BB%E8%A7%88)

[webpack 的 loader 和 plugin 区别是什么？](https://github.com/febobo/web-interview/issues/125)常用的 [plugin](https://github.com/pro-collection/interview-question/issues/594) 和 [loader](https://github.com/pro-collection/interview-question/issues/593) 有哪些？

[webpack 构建流程是什么？](https://github.com/pro-collection/interview-question/issues/283)

[讲讲 tree-shaking 原理。](https://github.com/pro-collection/interview-question/issues/247)

[什么情况下 webpack treeShaking 会失效](https://github.com/pro-collection/interview-question/issues/235)

[浏览器本身是不支持模块化的, webpack 是如何通过文件打包，让浏览器可以读取到前端各个模块的代码的](https://github.com/pro-collection/interview-question/issues/502)

---

# 性能优化

前端页面性能如何优化？

[讲讲回流和重绘的区别，如何避免回流和重绘？](https://github.com/febobo/web-interview/blob/master/docs/css/layout_painting.md)

[浏览器渲染一帧都做了什么？](https://juejin.cn/post/7111123122861899806)

---

# 安全

[网络攻击有哪些？如何防御？](https://github.com/febobo/web-interview/issues/92)

[如何防止 跨站脚本攻击 XSS](https://github.com/pro-collection/interview-question/issues/121)

[跨站请求伪造（Cross-Site Request Forgery, CSRF）](https://github.com/pro-collection/interview-question/issues/122)

---

# 计算机基础

[进程与线程区别是什么？](https://github.com/pro-collection/interview-question/issues/409)

[讲讲 TCP 三次握手、四次挥手，为什么要三次握手、四次挥手？](https://github.com/febobo/web-interview/issues/151)

[TCP 和 UDP 区别是什么？](https://github.com/pro-collection/interview-question/issues/72)

---

# 网络通信

[说说从输入 url 到页面展示出来的整个过程。](https://github.com/yd160513/blog/issues/17)

[什么是同源策略](https://github.com/pro-collection/interview-question/issues/412)

[什么是跨域？为什么会出现跨域？如何解决跨域问题？](https://juejin.cn/post/7092022569276014623)

[jsonp 原理 是什么？](https://github.com/pro-collection/interview-question/issues/15)

[CORS 是如何实现跨域的？](https://github.com/pro-collection/interview-question/issues/14)

[HTTP/1.0、HTTP/1.1、HTTP/2和HTTP/3之间的主要区别](https://github.com/pro-collection/interview-question/issues/528)

[HTTP 和 HTTPS 的区别](https://github.com/febobo/web-interview/issues/134)

- HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理，相对更安全
- HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是80，HTTPS是443
- HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP
- HTTPS需要SSL，SSL 证书需要钱，功能越强大的证书费用越高

[*https 原理是什么？为什么可以保证安全性？](https://github.com/febobo/web-interview/issues/135)

加密形式：

1. 对称加密：密钥都是相同的，这种是最直观简单的形式
2. 非对称加密：密钥不同，一把私钥对应一把公钥，私钥加密只有对应公钥解密，反过来公钥加密也只有对应私钥能解密

HTTPS = HTTP + SSL

SSL采用混合加密（对称加密+非对称加密），主要原因是因为非对称加密性能代价比较高，而对称加密较少，那么

1. 一开始通讯，用 『非对称加密』 交换 对称密钥 (`具体做法是发送密文的一方使用对方的公钥进行加密处理“对称的密钥”，然后对方用自己的私钥解密拿到“对称的密钥”`)
2. 之后每一次通讯，可以都用 『对称加密』
这样子性能和安全可以取到均衡
混合加密用了4把钥匙（非对称加密的公钥A和私钥B，对称加密的私钥C和私钥D），就解决了信息加密的过程

如何解决`完整性`问题？使用摘要！

发送方把 正文M 经过某种算法X 生成摘要G，正文M+摘要G 加密发给接收方，接收方解密生成 正文N+摘要G，正文经过算法X生成 摘要F，如果F==G，则正文N==M相同

如何解决`身份认证`？使用数字签名！

数字签名很简单，就是用私钥加密，公钥解密，其核心思想是，『只有真正的通信方才拥有这把私钥』，黑客不可能拥有这把私钥，这样就起到了身份认证。

`发送方生成摘要G后，用私钥加密，生成数字签名，数字签名和正文M一起发过去
接收方收到后，用公钥解密出数字签名，在经过算法X生成摘要F，如果F==G，则正文相同`

衍生一个问题，私钥是由真正通信方拥有，公钥也是由它发布，如何防止黑客发布假的公钥？CA数字证书认证机构！

CA采用的是非对称性加密，私钥由CA持有，公钥由浏览器持有，但是会事先内嵌在浏览器当中
通信方向CA申请公钥A，通过后CA把公钥A做数字签名，数字签名和公钥A绑定在一起，就是一份证书
通信方进行通信的时候会把这份证书传给接收方，这样接收方会对证书上的数字签名进行认证，如果认证通过，就能够表明该通信方的身份。

[http 常见状态码有哪些？](https://github.com/pro-collection/interview-question/issues/530)

http 有哪些方法？

[get 和 post 区别是什么？](https://github.com/pro-collection/interview-question/issues/536)

[讲讲 http 缓存机制。](https://www.51cto.com/article/746168.html)

[cdn 是什么？它的原理是什么？](https://github.com/pro-collection/interview-question/issues/297)

[讲讲 304 协商缓存过程。](https://juejin.cn/post/6974529351270268958#heading-15)

浏览器有哪些缓存？[localStorage、sessionStorage、cookie 的、session 的区别是什么？](https://github.com/pro-collection/interview-question/issues/104)

[常见的请求头和响应头](https://juejin.cn/post/6974529351270268958#heading-12)

[http2 多路复用是什么, 原理是什么](https://github.com/pro-collection/interview-question/issues/529)

[http1.1 的 keep-alive 和 http2 的多路复用 有什么区别](https://github.com/pro-collection/interview-question/issues/597)


## 问题

1. 看源码很费劲，也不是每行都能看懂，即使做了笔记，后面也会出现看不懂的情况，这种有什么好的办法解决？

2. 看过源码或者学习别人看源码的笔记，原理是懂了，但是时间久了，源码忘了，原理也会越来越模糊，这种有什么好的办法解决？